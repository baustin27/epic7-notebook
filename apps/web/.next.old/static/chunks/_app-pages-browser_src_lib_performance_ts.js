"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_src_lib_performance_ts"],{

/***/ "(app-pages-browser)/./src/lib/performance.ts":
/*!********************************!*\
  !*** ./src/lib/performance.ts ***!
  \********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PERFORMANCE_BUDGETS: () => (/* binding */ PERFORMANCE_BUDGETS),\n/* harmony export */   checkPerformanceBudgets: () => (/* binding */ checkPerformanceBudgets),\n/* harmony export */   createIntersectionObserver: () => (/* binding */ createIntersectionObserver),\n/* harmony export */   debouncedPerformanceLog: () => (/* binding */ debouncedPerformanceLog),\n/* harmony export */   getOptimizedImageUrl: () => (/* binding */ getOptimizedImageUrl),\n/* harmony export */   initPerformanceMonitoring: () => (/* binding */ initPerformanceMonitoring),\n/* harmony export */   logBundleSize: () => (/* binding */ logBundleSize),\n/* harmony export */   monitorCachePerformance: () => (/* binding */ monitorCachePerformance),\n/* harmony export */   monitorMemoryUsage: () => (/* binding */ monitorMemoryUsage),\n/* harmony export */   monitorNetworkRequests: () => (/* binding */ monitorNetworkRequests),\n/* harmony export */   monitorServiceWorker: () => (/* binding */ monitorServiceWorker),\n/* harmony export */   preloadCriticalResources: () => (/* binding */ preloadCriticalResources),\n/* harmony export */   preloadResource: () => (/* binding */ preloadResource),\n/* harmony export */   reportWebVitals: () => (/* binding */ reportWebVitals),\n/* harmony export */   trackBundleSize: () => (/* binding */ trackBundleSize)\n/* harmony export */ });\n/**\n * Performance optimization utilities for PWA\n */ // Core Web Vitals tracking\nfunction reportWebVitals(metric) {\n    // Log to console in development\n    if (true) {\n        console.log('Web Vital:', metric);\n    }\n    // Send to analytics in production\n    if (false) {}\n}\n// Image optimization helper\nfunction getOptimizedImageUrl(src, width, height) {\n    // Use Next.js Image optimization or a CDN\n    const params = new URLSearchParams({\n        url: src,\n        w: width.toString(),\n        ...height && {\n            h: height.toString()\n        },\n        q: '75',\n        f: 'webp' // Format\n    });\n    return \"/api/image?\".concat(params);\n}\n// Bundle size monitoring\nfunction logBundleSize() {\n    if ( true && 'performance' in window) {\n        // Log bundle size information\n        const resources = performance.getEntriesByType('resource');\n        const scripts = resources.filter((r)=>r.name.includes('.js'));\n        scripts.forEach((script)=>{\n            if (script.transferSize > 0) {\n                console.log(\"Bundle: \".concat(script.name, \" - \").concat((script.transferSize / 1024).toFixed(2), \"KB\"));\n            }\n        });\n    }\n}\n// Alias for backward compatibility\nconst trackBundleSize = logBundleSize;\n// Memory usage monitoring\nfunction monitorMemoryUsage() {\n    if ('memory' in performance) {\n        const memInfo = performance.memory;\n        console.log('Memory Usage:', {\n            used: Math.round(memInfo.usedJSHeapSize / 1048576 * 100) / 100 + ' MB',\n            total: Math.round(memInfo.totalJSHeapSize / 1048576 * 100) / 100 + ' MB',\n            limit: Math.round(memInfo.jsHeapSizeLimit / 1048576 * 100) / 100 + ' MB'\n        });\n    }\n}\n// Lazy loading with intersection observer\nfunction createIntersectionObserver(callback, options) {\n    if ( true && 'IntersectionObserver' in window) {\n        return new IntersectionObserver(callback, {\n            rootMargin: '50px',\n            threshold: 0.1,\n            ...options\n        });\n    }\n    return null;\n}\n// Debounced performance logging\nlet logTimeout;\nfunction debouncedPerformanceLog(message, data) {\n    clearTimeout(logTimeout);\n    logTimeout = setTimeout(()=>{\n        console.log(\"[Performance] \".concat(message), data);\n    }, 100);\n}\n// Resource preloading\nfunction preloadResource(href, as, type) {\n    if (typeof document !== 'undefined') {\n        const link = document.createElement('link');\n        link.rel = 'preload';\n        link.href = href;\n        link.as = as;\n        if (type) link.type = type;\n        document.head.appendChild(link);\n    }\n}\n// Critical resource preloading\nfunction preloadCriticalResources() {\n    // Preload critical fonts\n    preloadResource('/fonts/inter-var.woff2', 'font', 'font/woff2');\n    // Preload critical CSS\n    preloadResource('/_next/static/css/app.css', 'style');\n    // Preload critical JS\n    preloadResource('/_next/static/js/main.js', 'script');\n}\n// Service worker performance monitoring\nfunction monitorServiceWorker() {\n    if ('serviceWorker' in navigator) {\n        navigator.serviceWorker.addEventListener('message', (event)=>{\n            var _event_data;\n            if (((_event_data = event.data) === null || _event_data === void 0 ? void 0 : _event_data.type) === 'PERFORMANCE_METRIC') {\n                console.log('SW Performance:', event.data.metric);\n            }\n        });\n    }\n}\n// Cache performance monitoring\nfunction monitorCachePerformance() {\n    if ('caches' in window) {\n        caches.keys().then((cacheNames)=>{\n            cacheNames.forEach(async (cacheName)=>{\n                const cache = await caches.open(cacheName);\n                const keys = await cache.keys();\n                console.log(\"Cache \".concat(cacheName, \": \").concat(keys.length, \" items\"));\n            });\n        });\n    }\n}\n// Network request monitoring\nfunction monitorNetworkRequests() {\n    if ('PerformanceObserver' in window) {\n        const observer = new PerformanceObserver((list)=>{\n            for (const entry of list.getEntries()){\n                if (entry.entryType === 'resource') {\n                    const resourceEntry = entry;\n                    // Log slow network requests\n                    if (resourceEntry.responseEnd - resourceEntry.requestStart > 1000) {\n                        console.warn('Slow network request:', {\n                            url: resourceEntry.name,\n                            duration: resourceEntry.responseEnd - resourceEntry.requestStart,\n                            size: resourceEntry.transferSize\n                        });\n                    }\n                }\n            }\n        });\n        observer.observe({\n            entryTypes: [\n                'resource'\n            ]\n        });\n    }\n}\n// Initialize all performance monitoring\nfunction initPerformanceMonitoring() {\n    if (false) {}\n    // Preload critical resources\n    preloadCriticalResources();\n    // Monitor service worker\n    monitorServiceWorker();\n    // Monitor cache performance\n    monitorCachePerformance();\n    // Monitor network requests\n    monitorNetworkRequests();\n    // Log bundle sizes\n    logBundleSize();\n    // Monitor memory usage periodically\n    setInterval(monitorMemoryUsage, 30000);\n}\n// Performance budget checking\nconst PERFORMANCE_BUDGETS = {\n    // Bundle sizes\n    main: 200 * 1024,\n    vendor: 300 * 1024,\n    total: 500 * 1024,\n    // Web Vitals\n    lcp: 2500,\n    fid: 100,\n    cls: 0.1,\n    // Network\n    ttfb: 800,\n    fcp: 1800 // 1.8s\n};\nfunction checkPerformanceBudgets() {\n    if (false) {}\n    // Check bundle sizes\n    const resources = performance.getEntriesByType('resource');\n    const scripts = resources.filter((r)=>r.name.includes('.js'));\n    scripts.forEach((script)=>{\n        const size = script.transferSize;\n        if (size > PERFORMANCE_BUDGETS.main) {\n            console.warn(\"Bundle size exceeds budget: \".concat(script.name, \" (\").concat((size / 1024).toFixed(2), \"KB)\"));\n        }\n    });\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvcGVyZm9ybWFuY2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0NBRUMsR0FFRCwyQkFBMkI7QUFDcEIsU0FBU0EsZ0JBQWdCQyxNQUFXO0lBQ3pDLGdDQUFnQztJQUNoQyxJQUFJQyxJQUFzQyxFQUFFO1FBQzFDQyxRQUFRQyxHQUFHLENBQUMsY0FBY0g7SUFDNUI7SUFFQSxrQ0FBa0M7SUFDbEMsSUFBSUMsS0FBcUMsRUFBRSxFQUcxQztBQUNIO0FBRUEsNEJBQTRCO0FBQ3JCLFNBQVNHLHFCQUFxQkMsR0FBVyxFQUFFQyxLQUFhLEVBQUVDLE1BQWU7SUFDOUUsMENBQTBDO0lBQzFDLE1BQU1DLFNBQVMsSUFBSUMsZ0JBQWdCO1FBQ2pDQyxLQUFLTDtRQUNMTSxHQUFHTCxNQUFNTSxRQUFRO1FBQ2pCLEdBQUlMLFVBQVU7WUFBRU0sR0FBR04sT0FBT0ssUUFBUTtRQUFHLENBQUM7UUFDdENFLEdBQUc7UUFDSEMsR0FBRyxPQUFPLFNBQVM7SUFDckI7SUFFQSxPQUFPLGNBQXFCLE9BQVBQO0FBQ3ZCO0FBRUEseUJBQXlCO0FBQ2xCLFNBQVNRO0lBQ2QsSUFBSSxLQUE2QixJQUFJLGlCQUFpQkMsUUFBUTtRQUM1RCw4QkFBOEI7UUFDOUIsTUFBTUMsWUFBWUMsWUFBWUMsZ0JBQWdCLENBQUM7UUFDL0MsTUFBTUMsVUFBVUgsVUFBVUksTUFBTSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFQyxJQUFJLENBQUNDLFFBQVEsQ0FBQztRQUV0REosUUFBUUssT0FBTyxDQUFDQyxDQUFBQTtZQUNkLElBQUlBLE9BQU9DLFlBQVksR0FBRyxHQUFHO2dCQUMzQjFCLFFBQVFDLEdBQUcsQ0FBQyxXQUE0QixPQUFqQndCLE9BQU9ILElBQUksRUFBQyxPQUE2QyxPQUF4QyxDQUFDRyxPQUFPQyxZQUFZLEdBQUcsSUFBRyxFQUFHQyxPQUFPLENBQUMsSUFBRztZQUNsRjtRQUNGO0lBQ0Y7QUFDRjtBQUVB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QUFFO1lBQ25DL0YsUUFBUXVGLElBQUksQ0FBQywrQkFBK0MsT0FBaEI5RCxPQUFPSCxJQUFJLEVBQUMsTUFBNkIsT0FBekIsQ0FBQ21FLE9BQU8sSUFBRyxFQUFHOUQsT0FBTyxDQUFDLElBQUc7UUFDdkY7SUFDRjtBQUNGIiwic291cmNlcyI6WyIvaG9tZS9iYXVzdGluMjcvRGV2L25vdGVib29rL2FwcHMvd2ViL3NyYy9saWIvcGVyZm9ybWFuY2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBQZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24gdXRpbGl0aWVzIGZvciBQV0FcbiAqL1xuXG4vLyBDb3JlIFdlYiBWaXRhbHMgdHJhY2tpbmdcbmV4cG9ydCBmdW5jdGlvbiByZXBvcnRXZWJWaXRhbHMobWV0cmljOiBhbnkpIHtcbiAgLy8gTG9nIHRvIGNvbnNvbGUgaW4gZGV2ZWxvcG1lbnRcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgY29uc29sZS5sb2coJ1dlYiBWaXRhbDonLCBtZXRyaWMpXG4gIH1cblxuICAvLyBTZW5kIHRvIGFuYWx5dGljcyBpbiBwcm9kdWN0aW9uXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gU2VuZCB0byB5b3VyIGFuYWx5dGljcyBzZXJ2aWNlXG4gICAgLy8gRXhhbXBsZTogc2VuZFRvQW5hbHl0aWNzKG1ldHJpYylcbiAgfVxufVxuXG4vLyBJbWFnZSBvcHRpbWl6YXRpb24gaGVscGVyXG5leHBvcnQgZnVuY3Rpb24gZ2V0T3B0aW1pemVkSW1hZ2VVcmwoc3JjOiBzdHJpbmcsIHdpZHRoOiBudW1iZXIsIGhlaWdodD86IG51bWJlcik6IHN0cmluZyB7XG4gIC8vIFVzZSBOZXh0LmpzIEltYWdlIG9wdGltaXphdGlvbiBvciBhIENETlxuICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICB1cmw6IHNyYyxcbiAgICB3OiB3aWR0aC50b1N0cmluZygpLFxuICAgIC4uLihoZWlnaHQgJiYgeyBoOiBoZWlnaHQudG9TdHJpbmcoKSB9KSxcbiAgICBxOiAnNzUnLCAvLyBRdWFsaXR5XG4gICAgZjogJ3dlYnAnIC8vIEZvcm1hdFxuICB9KVxuXG4gIHJldHVybiBgL2FwaS9pbWFnZT8ke3BhcmFtc31gXG59XG5cbi8vIEJ1bmRsZSBzaXplIG1vbml0b3JpbmdcbmV4cG9ydCBmdW5jdGlvbiBsb2dCdW5kbGVTaXplKCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ3BlcmZvcm1hbmNlJyBpbiB3aW5kb3cpIHtcbiAgICAvLyBMb2cgYnVuZGxlIHNpemUgaW5mb3JtYXRpb25cbiAgICBjb25zdCByZXNvdXJjZXMgPSBwZXJmb3JtYW5jZS5nZXRFbnRyaWVzQnlUeXBlKCdyZXNvdXJjZScpXG4gICAgY29uc3Qgc2NyaXB0cyA9IHJlc291cmNlcy5maWx0ZXIociA9PiByLm5hbWUuaW5jbHVkZXMoJy5qcycpKVxuXG4gICAgc2NyaXB0cy5mb3JFYWNoKHNjcmlwdCA9PiB7XG4gICAgICBpZiAoc2NyaXB0LnRyYW5zZmVyU2l6ZSA+IDApIHtcbiAgICAgICAgY29uc29sZS5sb2coYEJ1bmRsZTogJHtzY3JpcHQubmFtZX0gLSAkeyhzY3JpcHQudHJhbnNmZXJTaXplIC8gMTAyNCkudG9GaXhlZCgyKX1LQmApXG4gICAgICB9XG4gICAgfSlcbiAgfVxufVxuXG4vLyBBbGlhcyBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuZXhwb3J0IGNvbnN0IHRyYWNrQnVuZGxlU2l6ZSA9IGxvZ0J1bmRsZVNpemVcblxuLy8gTWVtb3J5IHVzYWdlIG1vbml0b3JpbmdcbmV4cG9ydCBmdW5jdGlvbiBtb25pdG9yTWVtb3J5VXNhZ2UoKSB7XG4gIGlmICgnbWVtb3J5JyBpbiBwZXJmb3JtYW5jZSkge1xuICAgIGNvbnN0IG1lbUluZm8gPSAocGVyZm9ybWFuY2UgYXMgYW55KS5tZW1vcnlcbiAgICBjb25zb2xlLmxvZygnTWVtb3J5IFVzYWdlOicsIHtcbiAgICAgIHVzZWQ6IE1hdGgucm91bmQobWVtSW5mby51c2VkSlNIZWFwU2l6ZSAvIDEwNDg1NzYgKiAxMDApIC8gMTAwICsgJyBNQicsXG4gICAgICB0b3RhbDogTWF0aC5yb3VuZChtZW1JbmZvLnRvdGFsSlNIZWFwU2l6ZSAvIDEwNDg1NzYgKiAxMDApIC8gMTAwICsgJyBNQicsXG4gICAgICBsaW1pdDogTWF0aC5yb3VuZChtZW1JbmZvLmpzSGVhcFNpemVMaW1pdCAvIDEwNDg1NzYgKiAxMDApIC8gMTAwICsgJyBNQidcbiAgICB9KVxuICB9XG59XG5cbi8vIExhenkgbG9hZGluZyB3aXRoIGludGVyc2VjdGlvbiBvYnNlcnZlclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUludGVyc2VjdGlvbk9ic2VydmVyKFxuICBjYWxsYmFjazogSW50ZXJzZWN0aW9uT2JzZXJ2ZXJDYWxsYmFjayxcbiAgb3B0aW9ucz86IEludGVyc2VjdGlvbk9ic2VydmVySW5pdFxuKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAnSW50ZXJzZWN0aW9uT2JzZXJ2ZXInIGluIHdpbmRvdykge1xuICAgIHJldHVybiBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoY2FsbGJhY2ssIHtcbiAgICAgIHJvb3RNYXJnaW46ICc1MHB4JyxcbiAgICAgIHRocmVzaG9sZDogMC4xLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH0pXG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cblxuLy8gRGVib3VuY2VkIHBlcmZvcm1hbmNlIGxvZ2dpbmdcbmxldCBsb2dUaW1lb3V0OiBOb2RlSlMuVGltZW91dFxuZXhwb3J0IGZ1bmN0aW9uIGRlYm91bmNlZFBlcmZvcm1hbmNlTG9nKG1lc3NhZ2U6IHN0cmluZywgZGF0YT86IGFueSkge1xuICBjbGVhclRpbWVvdXQobG9nVGltZW91dClcbiAgbG9nVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKGBbUGVyZm9ybWFuY2VdICR7bWVzc2FnZX1gLCBkYXRhKVxuICB9LCAxMDApXG59XG5cbi8vIFJlc291cmNlIHByZWxvYWRpbmdcbmV4cG9ydCBmdW5jdGlvbiBwcmVsb2FkUmVzb3VyY2UoaHJlZjogc3RyaW5nLCBhczogc3RyaW5nLCB0eXBlPzogc3RyaW5nKSB7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc3QgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpbmsnKVxuICAgIGxpbmsucmVsID0gJ3ByZWxvYWQnXG4gICAgbGluay5ocmVmID0gaHJlZlxuICAgIGxpbmsuYXMgPSBhc1xuICAgIGlmICh0eXBlKSBsaW5rLnR5cGUgPSB0eXBlXG4gICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChsaW5rKVxuICB9XG59XG5cbi8vIENyaXRpY2FsIHJlc291cmNlIHByZWxvYWRpbmdcbmV4cG9ydCBmdW5jdGlvbiBwcmVsb2FkQ3JpdGljYWxSZXNvdXJjZXMoKSB7XG4gIC8vIFByZWxvYWQgY3JpdGljYWwgZm9udHNcbiAgcHJlbG9hZFJlc291cmNlKCcvZm9udHMvaW50ZXItdmFyLndvZmYyJywgJ2ZvbnQnLCAnZm9udC93b2ZmMicpXG5cbiAgLy8gUHJlbG9hZCBjcml0aWNhbCBDU1NcbiAgcHJlbG9hZFJlc291cmNlKCcvX25leHQvc3RhdGljL2Nzcy9hcHAuY3NzJywgJ3N0eWxlJylcblxuICAvLyBQcmVsb2FkIGNyaXRpY2FsIEpTXG4gIHByZWxvYWRSZXNvdXJjZSgnL19uZXh0L3N0YXRpYy9qcy9tYWluLmpzJywgJ3NjcmlwdCcpXG59XG5cbi8vIFNlcnZpY2Ugd29ya2VyIHBlcmZvcm1hbmNlIG1vbml0b3JpbmdcbmV4cG9ydCBmdW5jdGlvbiBtb25pdG9yU2VydmljZVdvcmtlcigpIHtcbiAgaWYgKCdzZXJ2aWNlV29ya2VyJyBpbiBuYXZpZ2F0b3IpIHtcbiAgICBuYXZpZ2F0b3Iuc2VydmljZVdvcmtlci5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgKGV2ZW50KSA9PiB7XG4gICAgICBpZiAoZXZlbnQuZGF0YT8udHlwZSA9PT0gJ1BFUkZPUk1BTkNFX01FVFJJQycpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1NXIFBlcmZvcm1hbmNlOicsIGV2ZW50LmRhdGEubWV0cmljKVxuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cblxuLy8gQ2FjaGUgcGVyZm9ybWFuY2UgbW9uaXRvcmluZ1xuZXhwb3J0IGZ1bmN0aW9uIG1vbml0b3JDYWNoZVBlcmZvcm1hbmNlKCkge1xuICBpZiAoJ2NhY2hlcycgaW4gd2luZG93KSB7XG4gICAgY2FjaGVzLmtleXMoKS50aGVuKGNhY2hlTmFtZXMgPT4ge1xuICAgICAgY2FjaGVOYW1lcy5mb3JFYWNoKGFzeW5jIChjYWNoZU5hbWUpID0+IHtcbiAgICAgICAgY29uc3QgY2FjaGUgPSBhd2FpdCBjYWNoZXMub3BlbihjYWNoZU5hbWUpXG4gICAgICAgIGNvbnN0IGtleXMgPSBhd2FpdCBjYWNoZS5rZXlzKClcbiAgICAgICAgY29uc29sZS5sb2coYENhY2hlICR7Y2FjaGVOYW1lfTogJHtrZXlzLmxlbmd0aH0gaXRlbXNgKVxuICAgICAgfSlcbiAgICB9KVxuICB9XG59XG5cbi8vIE5ldHdvcmsgcmVxdWVzdCBtb25pdG9yaW5nXG5leHBvcnQgZnVuY3Rpb24gbW9uaXRvck5ldHdvcmtSZXF1ZXN0cygpIHtcbiAgaWYgKCdQZXJmb3JtYW5jZU9ic2VydmVyJyBpbiB3aW5kb3cpIHtcbiAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBQZXJmb3JtYW5jZU9ic2VydmVyKChsaXN0KSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGxpc3QuZ2V0RW50cmllcygpKSB7XG4gICAgICAgIGlmIChlbnRyeS5lbnRyeVR5cGUgPT09ICdyZXNvdXJjZScpIHtcbiAgICAgICAgICBjb25zdCByZXNvdXJjZUVudHJ5ID0gZW50cnkgYXMgUGVyZm9ybWFuY2VSZXNvdXJjZVRpbWluZ1xuXG4gICAgICAgICAgLy8gTG9nIHNsb3cgbmV0d29yayByZXF1ZXN0c1xuICAgICAgICAgIGlmIChyZXNvdXJjZUVudHJ5LnJlc3BvbnNlRW5kIC0gcmVzb3VyY2VFbnRyeS5yZXF1ZXN0U3RhcnQgPiAxMDAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1Nsb3cgbmV0d29yayByZXF1ZXN0OicsIHtcbiAgICAgICAgICAgICAgdXJsOiByZXNvdXJjZUVudHJ5Lm5hbWUsXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiByZXNvdXJjZUVudHJ5LnJlc3BvbnNlRW5kIC0gcmVzb3VyY2VFbnRyeS5yZXF1ZXN0U3RhcnQsXG4gICAgICAgICAgICAgIHNpemU6IHJlc291cmNlRW50cnkudHJhbnNmZXJTaXplXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBvYnNlcnZlci5vYnNlcnZlKHsgZW50cnlUeXBlczogWydyZXNvdXJjZSddIH0pXG4gIH1cbn1cblxuLy8gSW5pdGlhbGl6ZSBhbGwgcGVyZm9ybWFuY2UgbW9uaXRvcmluZ1xuZXhwb3J0IGZ1bmN0aW9uIGluaXRQZXJmb3JtYW5jZU1vbml0b3JpbmcoKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuXG5cbiAgLy8gUHJlbG9hZCBjcml0aWNhbCByZXNvdXJjZXNcbiAgcHJlbG9hZENyaXRpY2FsUmVzb3VyY2VzKClcblxuICAvLyBNb25pdG9yIHNlcnZpY2Ugd29ya2VyXG4gIG1vbml0b3JTZXJ2aWNlV29ya2VyKClcblxuICAvLyBNb25pdG9yIGNhY2hlIHBlcmZvcm1hbmNlXG4gIG1vbml0b3JDYWNoZVBlcmZvcm1hbmNlKClcblxuICAvLyBNb25pdG9yIG5ldHdvcmsgcmVxdWVzdHNcbiAgbW9uaXRvck5ldHdvcmtSZXF1ZXN0cygpXG5cbiAgLy8gTG9nIGJ1bmRsZSBzaXplc1xuICBsb2dCdW5kbGVTaXplKClcblxuICAvLyBNb25pdG9yIG1lbW9yeSB1c2FnZSBwZXJpb2RpY2FsbHlcbiAgc2V0SW50ZXJ2YWwobW9uaXRvck1lbW9yeVVzYWdlLCAzMDAwMClcbn1cblxuLy8gUGVyZm9ybWFuY2UgYnVkZ2V0IGNoZWNraW5nXG5leHBvcnQgY29uc3QgUEVSRk9STUFOQ0VfQlVER0VUUyA9IHtcbiAgLy8gQnVuZGxlIHNpemVzXG4gIG1haW46IDIwMCAqIDEwMjQsIC8vIDIwMEtCXG4gIHZlbmRvcjogMzAwICogMTAyNCwgLy8gMzAwS0JcbiAgdG90YWw6IDUwMCAqIDEwMjQsIC8vIDUwMEtCXG5cbiAgLy8gV2ViIFZpdGFsc1xuICBsY3A6IDI1MDAsIC8vIDIuNXNcbiAgZmlkOiAxMDAsIC8vIDEwMG1zXG4gIGNsczogMC4xLCAvLyAwLjFcblxuICAvLyBOZXR3b3JrXG4gIHR0ZmI6IDgwMCwgLy8gODAwbXNcbiAgZmNwOiAxODAwIC8vIDEuOHNcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrUGVyZm9ybWFuY2VCdWRnZXRzKCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVyblxuXG4gIC8vIENoZWNrIGJ1bmRsZSBzaXplc1xuICBjb25zdCByZXNvdXJjZXMgPSBwZXJmb3JtYW5jZS5nZXRFbnRyaWVzQnlUeXBlKCdyZXNvdXJjZScpXG4gIGNvbnN0IHNjcmlwdHMgPSByZXNvdXJjZXMuZmlsdGVyKHIgPT4gci5uYW1lLmluY2x1ZGVzKCcuanMnKSlcblxuICBzY3JpcHRzLmZvckVhY2goc2NyaXB0ID0+IHtcbiAgICBjb25zdCBzaXplID0gc2NyaXB0LnRyYW5zZmVyU2l6ZVxuICAgIGlmIChzaXplID4gUEVSRk9STUFOQ0VfQlVER0VUUy5tYWluKSB7XG4gICAgICBjb25zb2xlLndhcm4oYEJ1bmRsZSBzaXplIGV4Y2VlZHMgYnVkZ2V0OiAke3NjcmlwdC5uYW1lfSAoJHsoc2l6ZSAvIDEwMjQpLnRvRml4ZWQoMil9S0IpYClcbiAgICB9XG4gIH0pXG59Il0sIm5hbWVzIjpbInJlcG9ydFdlYlZpdGFscyIsIm1ldHJpYyIsInByb2Nlc3MiLCJjb25zb2xlIiwibG9nIiwiZ2V0T3B0aW1pemVkSW1hZ2VVcmwiLCJzcmMiLCJ3aWR0aCIsImhlaWdodCIsInBhcmFtcyIsIlVSTFNlYXJjaFBhcmFtcyIsInVybCIsInciLCJ0b1N0cmluZyIsImgiLCJxIiwiZiIsImxvZ0J1bmRsZVNpemUiLCJ3aW5kb3ciLCJyZXNvdXJjZXMiLCJwZXJmb3JtYW5jZSIsImdldEVudHJpZXNCeVR5cGUiLCJzY3JpcHRzIiwiZmlsdGVyIiwiciIsIm5hbWUiLCJpbmNsdWRlcyIsImZvckVhY2giLCJzY3JpcHQiLCJ0cmFuc2ZlclNpemUiLCJ0b0ZpeGVkIiwidHJhY2tCdW5kbGVTaXplIiwibW9uaXRvck1lbW9yeVVzYWdlIiwibWVtSW5mbyIsIm1lbW9yeSIsInVzZWQiLCJNYXRoIiwicm91bmQiLCJ1c2VkSlNIZWFwU2l6ZSIsInRvdGFsIiwidG90YWxKU0hlYXBTaXplIiwibGltaXQiLCJqc0hlYXBTaXplTGltaXQiLCJjcmVhdGVJbnRlcnNlY3Rpb25PYnNlcnZlciIsImNhbGxiYWNrIiwib3B0aW9ucyIsIkludGVyc2VjdGlvbk9ic2VydmVyIiwicm9vdE1hcmdpbiIsInRocmVzaG9sZCIsImxvZ1RpbWVvdXQiLCJkZWJvdW5jZWRQZXJmb3JtYW5jZUxvZyIsIm1lc3NhZ2UiLCJkYXRhIiwiY2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsInByZWxvYWRSZXNvdXJjZSIsImhyZWYiLCJhcyIsInR5cGUiLCJkb2N1bWVudCIsImxpbmsiLCJjcmVhdGVFbGVtZW50IiwicmVsIiwiaGVhZCIsImFwcGVuZENoaWxkIiwicHJlbG9hZENyaXRpY2FsUmVzb3VyY2VzIiwibW9uaXRvclNlcnZpY2VXb3JrZXIiLCJuYXZpZ2F0b3IiLCJzZXJ2aWNlV29ya2VyIiwiYWRkRXZlbnRMaXN0ZW5lciIsImV2ZW50IiwibW9uaXRvckNhY2hlUGVyZm9ybWFuY2UiLCJjYWNoZXMiLCJrZXlzIiwidGhlbiIsImNhY2hlTmFtZXMiLCJjYWNoZU5hbWUiLCJjYWNoZSIsIm9wZW4iLCJsZW5ndGgiLCJtb25pdG9yTmV0d29ya1JlcXVlc3RzIiwib2JzZXJ2ZXIiLCJQZXJmb3JtYW5jZU9ic2VydmVyIiwibGlzdCIsImVudHJ5IiwiZ2V0RW50cmllcyIsImVudHJ5VHlwZSIsInJlc291cmNlRW50cnkiLCJyZXNwb25zZUVuZCIsInJlcXVlc3RTdGFydCIsIndhcm4iLCJkdXJhdGlvbiIsInNpemUiLCJvYnNlcnZlIiwiZW50cnlUeXBlcyIsImluaXRQZXJmb3JtYW5jZU1vbml0b3JpbmciLCJzZXRJbnRlcnZhbCIsIlBFUkZPUk1BTkNFX0JVREdFVFMiLCJtYWluIiwidmVuZG9yIiwibGNwIiwiZmlkIiwiY2xzIiwidHRmYiIsImZjcCIsImNoZWNrUGVyZm9ybWFuY2VCdWRnZXRzIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/performance.ts\n"));

/***/ })

}]);