"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_src_lib_analyticsService_ts"],{

/***/ "(app-pages-browser)/./src/lib/analyticsService.ts":
/*!*************************************!*\
  !*** ./src/lib/analyticsService.ts ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AnalyticsService: () => (/* binding */ AnalyticsService),\n/* harmony export */   analyticsService: () => (/* binding */ analyticsService)\n/* harmony export */ });\n/* harmony import */ var _supabase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./supabase */ \"(app-pages-browser)/./src/lib/supabase.ts\");\n\nclass AnalyticsService {\n    getOrCreateSessionId() {\n        // Check if we're in a browser environment\n        if (false) {}\n        let sessionId = localStorage.getItem('analytics_session_id');\n        if (!sessionId) {\n            sessionId = \"session_\".concat(Date.now(), \"_\").concat(Math.random().toString(36).substr(2, 9));\n            localStorage.setItem('analytics_session_id', sessionId);\n        }\n        return sessionId;\n    }\n    /**\n   * Track a user interaction event\n   */ async trackEvent(eventType) {\n        let eventData = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, userId = arguments.length > 2 ? arguments[2] : void 0;\n        try {\n            const event = {\n                user_id: userId,\n                event_type: eventType,\n                event_data: eventData,\n                session_id: this.sessionId,\n                ip_address: null,\n                user_agent: navigator.userAgent\n            };\n            const { error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('analytics_events').insert(event);\n            if (error) {\n                console.warn('Failed to track analytics event:', error);\n            }\n        } catch (error) {\n            console.warn('Analytics tracking failed:', error);\n        }\n    }\n    /**\n   * Track model performance metrics\n   */ async trackModelPerformance(userId, conversationId, model, metrics) {\n        try {\n            const performance = {\n                user_id: userId,\n                conversation_id: conversationId,\n                model,\n                prompt_tokens: metrics.promptTokens,\n                completion_tokens: metrics.completionTokens,\n                total_tokens: metrics.totalTokens,\n                response_time_ms: metrics.responseTimeMs,\n                cost_cents: metrics.costCents,\n                success: metrics.success,\n                error_message: metrics.errorMessage\n            };\n            const { error } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('model_performance').insert(performance);\n            if (error) {\n                console.warn('Failed to track model performance:', error);\n            }\n        } catch (error) {\n            console.warn('Model performance tracking failed:', error);\n        }\n    }\n    /**\n   * Update user engagement metrics\n   */ async updateUserEngagement(userId) {\n        try {\n            const today = new Date().toISOString().split('T')[0];\n            // First, try to update existing record\n            const { error: updateError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('user_engagement').update({\n                last_activity: new Date().toISOString(),\n                updated_at: new Date().toISOString()\n            }).eq('user_id', userId).eq('date', today);\n            if (updateError) {\n                // If no existing record, create one\n                const engagement = {\n                    user_id: userId,\n                    date: today,\n                    messages_sent: 0,\n                    conversations_created: 0,\n                    session_duration_minutes: 0,\n                    models_used: [],\n                    features_used: [],\n                    last_activity: new Date().toISOString()\n                };\n                const { error: insertError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('user_engagement').insert(engagement);\n                if (insertError) {\n                    console.warn('Failed to create user engagement record:', insertError);\n                }\n            }\n        } catch (error) {\n            console.warn('User engagement update failed:', error);\n        }\n    }\n    /**\n   * Increment message count for user\n   */ async incrementMessageCount(userId) {\n        try {\n            const today = new Date().toISOString().split('T')[0];\n            // Get current value\n            const { data: currentData, error: fetchError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('user_engagement').select('messages_sent').eq('user_id', userId).eq('date', today).single();\n            const currentCount = (currentData === null || currentData === void 0 ? void 0 : currentData.messages_sent) || 0;\n            // Update or insert\n            const { error: upsertError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('user_engagement').upsert({\n                user_id: userId,\n                date: today,\n                messages_sent: currentCount + 1,\n                last_activity: new Date().toISOString(),\n                updated_at: new Date().toISOString()\n            }, {\n                onConflict: 'user_id,date'\n            });\n            if (upsertError) {\n                console.warn('Failed to increment message count:', upsertError);\n            }\n        } catch (error) {\n            console.warn('Message count increment failed:', error);\n        }\n    }\n    /**\n   * Increment conversation count for user\n   */ async incrementConversationCount(userId) {\n        try {\n            const today = new Date().toISOString().split('T')[0];\n            // Get current value\n            const { data: currentData, error: fetchError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('user_engagement').select('conversations_created').eq('user_id', userId).eq('date', today).single();\n            const currentCount = (currentData === null || currentData === void 0 ? void 0 : currentData.conversations_created) || 0;\n            // Update or insert\n            const { error: upsertError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('user_engagement').upsert({\n                user_id: userId,\n                date: today,\n                conversations_created: currentCount + 1,\n                last_activity: new Date().toISOString(),\n                updated_at: new Date().toISOString()\n            }, {\n                onConflict: 'user_id,date'\n            });\n            if (upsertError) {\n                console.warn('Failed to increment conversation count:', upsertError);\n            }\n        } catch (error) {\n            console.warn('Conversation count increment failed:', error);\n        }\n    }\n    /**\n   * Track model usage for user\n   */ async trackModelUsage(userId, model) {\n        try {\n            const today = new Date().toISOString().split('T')[0];\n            // Get current models_used array\n            const { data: currentData, error: fetchError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('user_engagement').select('models_used').eq('user_id', userId).eq('date', today).single();\n            if (fetchError && fetchError.code !== 'PGRST116') {\n                console.warn('Failed to fetch current model usage:', fetchError);\n                return;\n            }\n            const currentModels = (currentData === null || currentData === void 0 ? void 0 : currentData.models_used) || [];\n            const updatedModels = Array.from(new Set([\n                ...currentModels,\n                model\n            ]));\n            // Update or insert\n            const { error: upsertError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('user_engagement').upsert({\n                user_id: userId,\n                date: today,\n                models_used: updatedModels,\n                last_activity: new Date().toISOString(),\n                updated_at: new Date().toISOString()\n            }, {\n                onConflict: 'user_id,date'\n            });\n            if (upsertError) {\n                console.warn('Failed to track model usage:', upsertError);\n            }\n        } catch (error) {\n            console.warn('Model usage tracking failed:', error);\n        }\n    }\n    /**\n   * Track feature usage\n   */ async trackFeatureUsage(userId, feature) {\n        try {\n            const today = new Date().toISOString().split('T')[0];\n            // Get current features_used array\n            const { data: currentData, error: fetchError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('user_engagement').select('features_used').eq('user_id', userId).eq('date', today).single();\n            if (fetchError && fetchError.code !== 'PGRST116') {\n                console.warn('Failed to fetch current feature usage:', fetchError);\n                return;\n            }\n            const currentFeatures = (currentData === null || currentData === void 0 ? void 0 : currentData.features_used) || [];\n            const updatedFeatures = Array.from(new Set([\n                ...currentFeatures,\n                feature\n            ]));\n            // Update or insert\n            const { error: upsertError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('user_engagement').upsert({\n                user_id: userId,\n                date: today,\n                features_used: updatedFeatures,\n                last_activity: new Date().toISOString(),\n                updated_at: new Date().toISOString()\n            }, {\n                onConflict: 'user_id,date'\n            });\n            if (upsertError) {\n                console.warn('Failed to track feature usage:', upsertError);\n            }\n        } catch (error) {\n            console.warn('Feature usage tracking failed:', error);\n        }\n    }\n    /**\n   * Get analytics data for admin dashboard\n   */ async getAnalyticsData(dateRange) {\n        try {\n            // Get daily metrics\n            const { data: metrics, error: metricsError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('analytics_metrics').select('*').gte('date', dateRange.start).lte('date', dateRange.end).order('date', {\n                ascending: false\n            });\n            if (metricsError) throw metricsError;\n            // Get recent events\n            const { data: events, error: eventsError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('analytics_events').select(\"\\n          *,\\n          users:user_id (\\n            email,\\n            full_name\\n          )\\n        \").gte('created_at', dateRange.start).lte('created_at', dateRange.end).order('created_at', {\n                ascending: false\n            }).limit(100);\n            if (eventsError) throw eventsError;\n            // Get model performance data\n            const { data: performance, error: performanceError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('model_performance').select('*').gte('created_at', dateRange.start).lte('created_at', dateRange.end).order('created_at', {\n                ascending: false\n            });\n            if (performanceError) throw performanceError;\n            // Get user engagement data\n            const { data: engagement, error: engagementError } = await _supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from('user_engagement').select(\"\\n          *,\\n          users:user_id (\\n            email,\\n            full_name\\n          )\\n        \").gte('date', dateRange.start).lte('date', dateRange.end).order('date', {\n                ascending: false\n            });\n            if (engagementError) throw engagementError;\n            return {\n                metrics: metrics || [],\n                events: events || [],\n                performance: performance || [],\n                engagement: engagement || []\n            };\n        } catch (error) {\n            console.error('Failed to fetch analytics data:', error);\n            throw error;\n        }\n    }\n    constructor(){\n        // Generate a session ID for this browser session\n        this.sessionId = this.getOrCreateSessionId();\n    }\n}\nconst analyticsService = new AnalyticsService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvYW5hbHl0aWNzU2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBcUM7QUFPOUIsTUFBTUM7SUFRSEMsdUJBQStCO1FBQ3JDLDBDQUEwQztRQUMxQyxJQUFJLEtBQTZCLEVBQUUsRUFHbEM7UUFFRCxJQUFJTyxZQUFZQyxhQUFhQyxPQUFPLENBQUM7UUFDckMsSUFBSSxDQUFDRixXQUFXO1lBQ2RBLFlBQVksV0FBeUJOLE9BQWRDLEtBQUtDLEdBQUcsSUFBRyxLQUEyQyxPQUF4Q0YsS0FBS0csTUFBTSxHQUFHQyxRQUFRLENBQUMsSUFBSUMsTUFBTSxDQUFDLEdBQUc7WUFDMUVFLGFBQWFFLE9BQU8sQ0FBQyx3QkFBd0JIO1FBQy9DO1FBQ0EsT0FBT0E7SUFDVDtJQUVBOztHQUVDLEdBQ0QsTUFBTUksV0FDSkMsU0FBaUIsRUFHRjtZQUZmQyxZQUFBQSxpRUFBaUMsQ0FBQyxHQUNsQ0M7UUFFQSxJQUFJO1lBQ0YsTUFBTUMsUUFBd0I7Z0JBQzVCQyxTQUFTRjtnQkFDVEcsWUFBWUw7Z0JBQ1pNLFlBQVlMO2dCQUNaTSxZQUFZLElBQUksQ0FBQ1osU0FBUztnQkFDMUJhLFlBQVk7Z0JBQ1pDLFlBQVlDLFVBQVVDLFNBQVM7WUFDakM7WUFFQSxNQUFNLEVBQUVDLEtBQUssRUFBRSxHQUFHLE1BQU0xQiwrQ0FBUUEsQ0FDN0IyQixJQUFJLENBQUMsb0JBQ0xDLE1BQU0sQ0FBQ1g7WUFFVixJQUFJUyxPQUFPO2dCQUNURyxRQUFRQyxJQUFJLENBQUMsb0NBQW9DSjtZQUNuRDtRQUNGLEVBQUUsT0FBT0EsT0FBTztZQUNkRyxRQUFRQyxJQUFJLENBQUMsOEJBQThCSjtRQUM3QztJQUNGO0lBRUE7O0dBRUMsR0FDRCxNQUFNSyxzQkFDSmYsTUFBYyxFQUNkZ0IsY0FBc0IsRUFDdEJDLEtBQWEsRUFDYkMsT0FRQyxFQUNjO1FBQ2YsSUFBSTtZQUNGLE1BQU1DLGNBQWdDO2dCQUNwQ2pCLFNBQVNGO2dCQUNUb0Is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RXBDLElBQUlLLGlCQUFpQixNQUFNQTtZQUUzQixPQUFPO2dCQUNMbkUsU0FBU0EsV0FBVyxFQUFFO2dCQUN0QitELFFBQVFBLFVBQVUsRUFBRTtnQkFDcEI5RCxhQUFhQSxlQUFlLEVBQUU7Z0JBQzlCd0IsWUFBWUEsY0FBYyxFQUFFO1lBQzlCO1FBQ0YsRUFBRSxPQUFPakMsT0FBTztZQUNkRyxRQUFRSCxLQUFLLENBQUMsbUNBQW1DQTtZQUNqRCxNQUFNQTtRQUNSO0lBQ0Y7SUFoWEEsYUFBYztRQUNaLGlEQUFpRDtRQUNqRCxJQUFJLENBQUNqQixTQUFTLEdBQUcsSUFBSSxDQUFDUCxvQkFBb0I7SUFDNUM7QUE4V0Y7QUFFTyxNQUFNb0csbUJBQW1CLElBQUlyRyxtQkFBa0IiLCJzb3VyY2VzIjpbIi9ob21lL2JhdXN0aW4yNy9EZXYvbm90ZWJvb2svYXBwcy93ZWIvc3JjL2xpYi9hbmFseXRpY3NTZXJ2aWNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHN1cGFiYXNlIH0gZnJvbSAnLi9zdXBhYmFzZSdcbmltcG9ydCB0eXBlIHsgRGF0YWJhc2UgfSBmcm9tICcuLi90eXBlcy9kYXRhYmFzZSdcblxudHlwZSBBbmFseXRpY3NFdmVudCA9IERhdGFiYXNlWydwdWJsaWMnXVsnVGFibGVzJ11bJ2FuYWx5dGljc19ldmVudHMnXVsnSW5zZXJ0J11cbnR5cGUgTW9kZWxQZXJmb3JtYW5jZSA9IERhdGFiYXNlWydwdWJsaWMnXVsnVGFibGVzJ11bJ21vZGVsX3BlcmZvcm1hbmNlJ11bJ0luc2VydCddXG50eXBlIFVzZXJFbmdhZ2VtZW50ID0gRGF0YWJhc2VbJ3B1YmxpYyddWydUYWJsZXMnXVsndXNlcl9lbmdhZ2VtZW50J11bJ0luc2VydCddXG5cbmV4cG9ydCBjbGFzcyBBbmFseXRpY3NTZXJ2aWNlIHtcbiAgcHJpdmF0ZSBzZXNzaW9uSWQ6IHN0cmluZ1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8vIEdlbmVyYXRlIGEgc2Vzc2lvbiBJRCBmb3IgdGhpcyBicm93c2VyIHNlc3Npb25cbiAgICB0aGlzLnNlc3Npb25JZCA9IHRoaXMuZ2V0T3JDcmVhdGVTZXNzaW9uSWQoKVxuICB9XG5cbiAgcHJpdmF0ZSBnZXRPckNyZWF0ZVNlc3Npb25JZCgpOiBzdHJpbmcge1xuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGluIGEgYnJvd3NlciBlbnZpcm9ubWVudFxuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gU2VydmVyLXNpZGU6IGdlbmVyYXRlIGEgdGVtcG9yYXJ5IHNlc3Npb24gSURcbiAgICAgIHJldHVybiBgc2VydmVyX3Nlc3Npb25fJHtEYXRlLm5vdygpfV8ke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA5KX1gXG4gICAgfVxuICAgIFxuICAgIGxldCBzZXNzaW9uSWQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnYW5hbHl0aWNzX3Nlc3Npb25faWQnKVxuICAgIGlmICghc2Vzc2lvbklkKSB7XG4gICAgICBzZXNzaW9uSWQgPSBgc2Vzc2lvbl8ke0RhdGUubm93KCl9XyR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDkpfWBcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdhbmFseXRpY3Nfc2Vzc2lvbl9pZCcsIHNlc3Npb25JZClcbiAgICB9XG4gICAgcmV0dXJuIHNlc3Npb25JZFxuICB9XG5cbiAgLyoqXG4gICAqIFRyYWNrIGEgdXNlciBpbnRlcmFjdGlvbiBldmVudFxuICAgKi9cbiAgYXN5bmMgdHJhY2tFdmVudChcbiAgICBldmVudFR5cGU6IHN0cmluZyxcbiAgICBldmVudERhdGE6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7fSxcbiAgICB1c2VySWQ/OiBzdHJpbmdcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGV2ZW50OiBBbmFseXRpY3NFdmVudCA9IHtcbiAgICAgICAgdXNlcl9pZDogdXNlcklkLFxuICAgICAgICBldmVudF90eXBlOiBldmVudFR5cGUsXG4gICAgICAgIGV2ZW50X2RhdGE6IGV2ZW50RGF0YSxcbiAgICAgICAgc2Vzc2lvbl9pZDogdGhpcy5zZXNzaW9uSWQsXG4gICAgICAgIGlwX2FkZHJlc3M6IG51bGwsIC8vIFdpbGwgYmUgc2V0IGJ5IHNlcnZlciBpZiBuZWVkZWRcbiAgICAgICAgdXNlcl9hZ2VudDogbmF2aWdhdG9yLnVzZXJBZ2VudFxuICAgICAgfVxuXG4gICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnYW5hbHl0aWNzX2V2ZW50cycpXG4gICAgICAgIC5pbnNlcnQoZXZlbnQpXG5cbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byB0cmFjayBhbmFseXRpY3MgZXZlbnQ6JywgZXJyb3IpXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybignQW5hbHl0aWNzIHRyYWNraW5nIGZhaWxlZDonLCBlcnJvcilcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVHJhY2sgbW9kZWwgcGVyZm9ybWFuY2UgbWV0cmljc1xuICAgKi9cbiAgYXN5bmMgdHJhY2tNb2RlbFBlcmZvcm1hbmNlKFxuICAgIHVzZXJJZDogc3RyaW5nLFxuICAgIGNvbnZlcnNhdGlvbklkOiBzdHJpbmcsXG4gICAgbW9kZWw6IHN0cmluZyxcbiAgICBtZXRyaWNzOiB7XG4gICAgICBwcm9tcHRUb2tlbnM/OiBudW1iZXJcbiAgICAgIGNvbXBsZXRpb25Ub2tlbnM/OiBudW1iZXJcbiAgICAgIHRvdGFsVG9rZW5zPzogbnVtYmVyXG4gICAgICByZXNwb25zZVRpbWVNcz86IG51bWJlclxuICAgICAgY29zdENlbnRzPzogbnVtYmVyXG4gICAgICBzdWNjZXNzOiBib29sZWFuXG4gICAgICBlcnJvck1lc3NhZ2U/OiBzdHJpbmdcbiAgICB9XG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwZXJmb3JtYW5jZTogTW9kZWxQZXJmb3JtYW5jZSA9IHtcbiAgICAgICAgdXNlcl9pZDogdXNlcklkLFxuICAgICAgICBjb252ZXJzYXRpb25faWQ6IGNvbnZlcnNhdGlvbklkLFxuICAgICAgICBtb2RlbCxcbiAgICAgICAgcHJvbXB0X3Rva2VuczogbWV0cmljcy5wcm9tcHRUb2tlbnMsXG4gICAgICAgIGNvbXBsZXRpb25fdG9rZW5zOiBtZXRyaWNzLmNvbXBsZXRpb25Ub2tlbnMsXG4gICAgICAgIHRvdGFsX3Rva2VuczogbWV0cmljcy50b3RhbFRva2VucyxcbiAgICAgICAgcmVzcG9uc2VfdGltZV9tczogbWV0cmljcy5yZXNwb25zZVRpbWVNcyxcbiAgICAgICAgY29zdF9jZW50czogbWV0cmljcy5jb3N0Q2VudHMsXG4gICAgICAgIHN1Y2Nlc3M6IG1ldHJpY3Muc3VjY2VzcyxcbiAgICAgICAgZXJyb3JfbWVzc2FnZTogbWV0cmljcy5lcnJvck1lc3NhZ2VcbiAgICAgIH1cblxuICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ21vZGVsX3BlcmZvcm1hbmNlJylcbiAgICAgICAgLmluc2VydChwZXJmb3JtYW5jZSlcblxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHRyYWNrIG1vZGVsIHBlcmZvcm1hbmNlOicsIGVycm9yKVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ01vZGVsIHBlcmZvcm1hbmNlIHRyYWNraW5nIGZhaWxlZDonLCBlcnJvcilcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHVzZXIgZW5nYWdlbWVudCBtZXRyaWNzXG4gICAqL1xuICBhc3luYyB1cGRhdGVVc2VyRW5nYWdlbWVudCh1c2VySWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB0b2RheSA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdXG5cbiAgICAgIC8vIEZpcnN0LCB0cnkgdG8gdXBkYXRlIGV4aXN0aW5nIHJlY29yZFxuICAgICAgY29uc3QgeyBlcnJvcjogdXBkYXRlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCd1c2VyX2VuZ2FnZW1lbnQnKVxuICAgICAgICAudXBkYXRlKHtcbiAgICAgICAgICBsYXN0X2FjdGl2aXR5OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgIH0pXG4gICAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXJJZClcbiAgICAgICAgLmVxKCdkYXRlJywgdG9kYXkpXG5cbiAgICAgIGlmICh1cGRhdGVFcnJvcikge1xuICAgICAgICAvLyBJZiBubyBleGlzdGluZyByZWNvcmQsIGNyZWF0ZSBvbmVcbiAgICAgICAgY29uc3QgZW5nYWdlbWVudDogVXNlckVuZ2FnZW1lbnQgPSB7XG4gICAgICAgICAgdXNlcl9pZDogdXNlcklkLFxuICAgICAgICAgIGRhdGU6IHRvZGF5LFxuICAgICAgICAgIG1lc3NhZ2VzX3NlbnQ6IDAsXG4gICAgICAgICAgY29udmVyc2F0aW9uc19jcmVhdGVkOiAwLFxuICAgICAgICAgIHNlc3Npb25fZHVyYXRpb25fbWludXRlczogMCxcbiAgICAgICAgICBtb2RlbHNfdXNlZDogW10sXG4gICAgICAgICAgZmVhdHVyZXNfdXNlZDogW10sXG4gICAgICAgICAgbGFzdF9hY3Rpdml0eTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IGVycm9yOiBpbnNlcnRFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAuZnJvbSgndXNlcl9lbmdhZ2VtZW50JylcbiAgICAgICAgICAuaW5zZXJ0KGVuZ2FnZW1lbnQpXG5cbiAgICAgICAgaWYgKGluc2VydEVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gY3JlYXRlIHVzZXIgZW5nYWdlbWVudCByZWNvcmQ6JywgaW5zZXJ0RXJyb3IpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKCdVc2VyIGVuZ2FnZW1lbnQgdXBkYXRlIGZhaWxlZDonLCBlcnJvcilcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5jcmVtZW50IG1lc3NhZ2UgY291bnQgZm9yIHVzZXJcbiAgICovXG4gIGFzeW5jIGluY3JlbWVudE1lc3NhZ2VDb3VudCh1c2VySWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB0b2RheSA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdXG5cbiAgICAgIC8vIEdldCBjdXJyZW50IHZhbHVlXG4gICAgICBjb25zdCB7IGRhdGE6IGN1cnJlbnREYXRhLCBlcnJvcjogZmV0Y2hFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3VzZXJfZW5nYWdlbWVudCcpXG4gICAgICAgIC5zZWxlY3QoJ21lc3NhZ2VzX3NlbnQnKVxuICAgICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VySWQpXG4gICAgICAgIC5lcSgnZGF0ZScsIHRvZGF5KVxuICAgICAgICAuc2luZ2xlKClcblxuICAgICAgY29uc3QgY3VycmVudENvdW50ID0gY3VycmVudERhdGE/Lm1lc3NhZ2VzX3NlbnQgfHwgMFxuXG4gICAgICAvLyBVcGRhdGUgb3IgaW5zZXJ0XG4gICAgICBjb25zdCB7IGVycm9yOiB1cHNlcnRFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3VzZXJfZW5nYWdlbWVudCcpXG4gICAgICAgIC51cHNlcnQoe1xuICAgICAgICAgIHVzZXJfaWQ6IHVzZXJJZCxcbiAgICAgICAgICBkYXRlOiB0b2RheSxcbiAgICAgICAgICBtZXNzYWdlc19zZW50OiBjdXJyZW50Q291bnQgKyAxLFxuICAgICAgICAgIGxhc3RfYWN0aXZpdHk6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgfSwge1xuICAgICAgICAgIG9uQ29uZmxpY3Q6ICd1c2VyX2lkLGRhdGUnXG4gICAgICAgIH0pXG5cbiAgICAgIGlmICh1cHNlcnRFcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBpbmNyZW1lbnQgbWVzc2FnZSBjb3VudDonLCB1cHNlcnRFcnJvcilcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKCdNZXNzYWdlIGNvdW50IGluY3JlbWVudCBmYWlsZWQ6JywgZXJyb3IpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluY3JlbWVudCBjb252ZXJzYXRpb24gY291bnQgZm9yIHVzZXJcbiAgICovXG4gIGFzeW5jIGluY3JlbWVudENvbnZlcnNhdGlvbkNvdW50KHVzZXJJZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHRvZGF5ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF1cblxuICAgICAgLy8gR2V0IGN1cnJlbnQgdmFsdWVcbiAgICAgIGNvbnN0IHsgZGF0YTogY3VycmVudERhdGEsIGVycm9yOiBmZXRjaEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgndXNlcl9lbmdhZ2VtZW50JylcbiAgICAgICAgLnNlbGVjdCgnY29udmVyc2F0aW9uc19jcmVhdGVkJylcbiAgICAgICAgLmVxKCd1c2VyX2lkJywgdXNlcklkKVxuICAgICAgICAuZXEoJ2RhdGUnLCB0b2RheSlcbiAgICAgICAgLnNpbmdsZSgpXG5cbiAgICAgIGNvbnN0IGN1cnJlbnRDb3VudCA9IGN1cnJlbnREYXRhPy5jb252ZXJzYXRpb25zX2NyZWF0ZWQgfHwgMFxuXG4gICAgICAvLyBVcGRhdGUgb3IgaW5zZXJ0XG4gICAgICBjb25zdCB7IGVycm9yOiB1cHNlcnRFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3VzZXJfZW5nYWdlbWVudCcpXG4gICAgICAgIC51cHNlcnQoe1xuICAgICAgICAgIHVzZXJfaWQ6IHVzZXJJZCxcbiAgICAgICAgICBkYXRlOiB0b2RheSxcbiAgICAgICAgICBjb252ZXJzYXRpb25zX2NyZWF0ZWQ6IGN1cnJlbnRDb3VudCArIDEsXG4gICAgICAgICAgbGFzdF9hY3Rpdml0eTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICB9LCB7XG4gICAgICAgICAgb25Db25mbGljdDogJ3VzZXJfaWQsZGF0ZSdcbiAgICAgICAgfSlcblxuICAgICAgaWYgKHVwc2VydEVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIGluY3JlbWVudCBjb252ZXJzYXRpb24gY291bnQ6JywgdXBzZXJ0RXJyb3IpXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybignQ29udmVyc2F0aW9uIGNvdW50IGluY3JlbWVudCBmYWlsZWQ6JywgZXJyb3IpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRyYWNrIG1vZGVsIHVzYWdlIGZvciB1c2VyXG4gICAqL1xuICBhc3luYyB0cmFja01vZGVsVXNhZ2UodXNlcklkOiBzdHJpbmcsIG1vZGVsOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXVxuXG4gICAgICAvLyBHZXQgY3VycmVudCBtb2RlbHNfdXNlZCBhcnJheVxuICAgICAgY29uc3QgeyBkYXRhOiBjdXJyZW50RGF0YSwgZXJyb3I6IGZldGNoRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCd1c2VyX2VuZ2FnZW1lbnQnKVxuICAgICAgICAuc2VsZWN0KCdtb2RlbHNfdXNlZCcpXG4gICAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXJJZClcbiAgICAgICAgLmVxKCdkYXRlJywgdG9kYXkpXG4gICAgICAgIC5zaW5nbGUoKVxuXG4gICAgICBpZiAoZmV0Y2hFcnJvciAmJiBmZXRjaEVycm9yLmNvZGUgIT09ICdQR1JTVDExNicpIHsgLy8gUEdSU1QxMTYgPSBubyByb3dzXG4gICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIGZldGNoIGN1cnJlbnQgbW9kZWwgdXNhZ2U6JywgZmV0Y2hFcnJvcilcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGN1cnJlbnRNb2RlbHMgPSBjdXJyZW50RGF0YT8ubW9kZWxzX3VzZWQgfHwgW11cbiAgICAgIGNvbnN0IHVwZGF0ZWRNb2RlbHMgPSBBcnJheS5mcm9tKG5ldyBTZXQoWy4uLmN1cnJlbnRNb2RlbHMsIG1vZGVsXSkpXG5cbiAgICAgIC8vIFVwZGF0ZSBvciBpbnNlcnRcbiAgICAgIGNvbnN0IHsgZXJyb3I6IHVwc2VydEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgndXNlcl9lbmdhZ2VtZW50JylcbiAgICAgICAgLnVwc2VydCh7XG4gICAgICAgICAgdXNlcl9pZDogdXNlcklkLFxuICAgICAgICAgIGRhdGU6IHRvZGF5LFxuICAgICAgICAgIG1vZGVsc191c2VkOiB1cGRhdGVkTW9kZWxzLFxuICAgICAgICAgIGxhc3RfYWN0aXZpdHk6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgfSwge1xuICAgICAgICAgIG9uQ29uZmxpY3Q6ICd1c2VyX2lkLGRhdGUnXG4gICAgICAgIH0pXG5cbiAgICAgIGlmICh1cHNlcnRFcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byB0cmFjayBtb2RlbCB1c2FnZTonLCB1cHNlcnRFcnJvcilcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKCdNb2RlbCB1c2FnZSB0cmFja2luZyBmYWlsZWQ6JywgZXJyb3IpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRyYWNrIGZlYXR1cmUgdXNhZ2VcbiAgICovXG4gIGFzeW5jIHRyYWNrRmVhdHVyZVVzYWdlKHVzZXJJZDogc3RyaW5nLCBmZWF0dXJlOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXVxuXG4gICAgICAvLyBHZXQgY3VycmVudCBmZWF0dXJlc191c2VkIGFycmF5XG4gICAgICBjb25zdCB7IGRhdGE6IGN1cnJlbnREYXRhLCBlcnJvcjogZmV0Y2hFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3VzZXJfZW5nYWdlbWVudCcpXG4gICAgICAgIC5zZWxlY3QoJ2ZlYXR1cmVzX3VzZWQnKVxuICAgICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VySWQpXG4gICAgICAgIC5lcSgnZGF0ZScsIHRvZGF5KVxuICAgICAgICAuc2luZ2xlKClcblxuICAgICAgaWYgKGZldGNoRXJyb3IgJiYgZmV0Y2hFcnJvci5jb2RlICE9PSAnUEdSU1QxMTYnKSB7IC8vIFBHUlNUMTE2ID0gbm8gcm93c1xuICAgICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBmZXRjaCBjdXJyZW50IGZlYXR1cmUgdXNhZ2U6JywgZmV0Y2hFcnJvcilcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGN1cnJlbnRGZWF0dXJlcyA9IGN1cnJlbnREYXRhPy5mZWF0dXJlc191c2VkIHx8IFtdXG4gICAgICBjb25zdCB1cGRhdGVkRmVhdHVyZXMgPSBBcnJheS5mcm9tKG5ldyBTZXQoWy4uLmN1cnJlbnRGZWF0dXJlcywgZmVhdHVyZV0pKVxuXG4gICAgICAvLyBVcGRhdGUgb3IgaW5zZXJ0XG4gICAgICBjb25zdCB7IGVycm9yOiB1cHNlcnRFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3VzZXJfZW5nYWdlbWVudCcpXG4gICAgICAgIC51cHNlcnQoe1xuICAgICAgICAgIHVzZXJfaWQ6IHVzZXJJZCxcbiAgICAgICAgICBkYXRlOiB0b2RheSxcbiAgICAgICAgICBmZWF0dXJlc191c2VkOiB1cGRhdGVkRmVhdHVyZXMsXG4gICAgICAgICAgbGFzdF9hY3Rpdml0eTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICB9LCB7XG4gICAgICAgICAgb25Db25mbGljdDogJ3VzZXJfaWQsZGF0ZSdcbiAgICAgICAgfSlcblxuICAgICAgaWYgKHVwc2VydEVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHRyYWNrIGZlYXR1cmUgdXNhZ2U6JywgdXBzZXJ0RXJyb3IpXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybignRmVhdHVyZSB1c2FnZSB0cmFja2luZyBmYWlsZWQ6JywgZXJyb3IpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbmFseXRpY3MgZGF0YSBmb3IgYWRtaW4gZGFzaGJvYXJkXG4gICAqL1xuICBhc3luYyBnZXRBbmFseXRpY3NEYXRhKGRhdGVSYW5nZTogeyBzdGFydDogc3RyaW5nOyBlbmQ6IHN0cmluZyB9KSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEdldCBkYWlseSBtZXRyaWNzXG4gICAgICBjb25zdCB7IGRhdGE6IG1ldHJpY3MsIGVycm9yOiBtZXRyaWNzRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdhbmFseXRpY3NfbWV0cmljcycpXG4gICAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgICAuZ3RlKCdkYXRlJywgZGF0ZVJhbmdlLnN0YXJ0KVxuICAgICAgICAubHRlKCdkYXRlJywgZGF0ZVJhbmdlLmVuZClcbiAgICAgICAgLm9yZGVyKCdkYXRlJywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXG5cbiAgICAgIGlmIChtZXRyaWNzRXJyb3IpIHRocm93IG1ldHJpY3NFcnJvclxuXG4gICAgICAvLyBHZXQgcmVjZW50IGV2ZW50c1xuICAgICAgY29uc3QgeyBkYXRhOiBldmVudHMsIGVycm9yOiBldmVudHNFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2FuYWx5dGljc19ldmVudHMnKVxuICAgICAgICAuc2VsZWN0KGBcbiAgICAgICAgICAqLFxuICAgICAgICAgIHVzZXJzOnVzZXJfaWQgKFxuICAgICAgICAgICAgZW1haWwsXG4gICAgICAgICAgICBmdWxsX25hbWVcbiAgICAgICAgICApXG4gICAgICAgIGApXG4gICAgICAgIC5ndGUoJ2NyZWF0ZWRfYXQnLCBkYXRlUmFuZ2Uuc3RhcnQpXG4gICAgICAgIC5sdGUoJ2NyZWF0ZWRfYXQnLCBkYXRlUmFuZ2UuZW5kKVxuICAgICAgICAub3JkZXIoJ2NyZWF0ZWRfYXQnLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcbiAgICAgICAgLmxpbWl0KDEwMClcblxuICAgICAgaWYgKGV2ZW50c0Vycm9yKSB0aHJvdyBldmVudHNFcnJvclxuXG4gICAgICAvLyBHZXQgbW9kZWwgcGVyZm9ybWFuY2UgZGF0YVxuICAgICAgY29uc3QgeyBkYXRhOiBwZXJmb3JtYW5jZSwgZXJyb3I6IHBlcmZvcm1hbmNlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdtb2RlbF9wZXJmb3JtYW5jZScpXG4gICAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgICAuZ3RlKCdjcmVhdGVkX2F0JywgZGF0ZVJhbmdlLnN0YXJ0KVxuICAgICAgICAubHRlKCdjcmVhdGVkX2F0JywgZGF0ZVJhbmdlLmVuZClcbiAgICAgICAgLm9yZGVyKCdjcmVhdGVkX2F0JywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXG5cbiAgICAgIGlmIChwZXJmb3JtYW5jZUVycm9yKSB0aHJvdyBwZXJmb3JtYW5jZUVycm9yXG5cbiAgICAgIC8vIEdldCB1c2VyIGVuZ2FnZW1lbnQgZGF0YVxuICAgICAgY29uc3QgeyBkYXRhOiBlbmdhZ2VtZW50LCBlcnJvcjogZW5nYWdlbWVudEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgndXNlcl9lbmdhZ2VtZW50JylcbiAgICAgICAgLnNlbGVjdChgXG4gICAgICAgICAgKixcbiAgICAgICAgICB1c2Vyczp1c2VyX2lkIChcbiAgICAgICAgICAgIGVtYWlsLFxuICAgICAgICAgICAgZnVsbF9uYW1lXG4gICAgICAgICAgKVxuICAgICAgICBgKVxuICAgICAgICAuZ3RlKCdkYXRlJywgZGF0ZVJhbmdlLnN0YXJ0KVxuICAgICAgICAubHRlKCdkYXRlJywgZGF0ZVJhbmdlLmVuZClcbiAgICAgICAgLm9yZGVyKCdkYXRlJywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXG5cbiAgICAgIGlmIChlbmdhZ2VtZW50RXJyb3IpIHRocm93IGVuZ2FnZW1lbnRFcnJvclxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBtZXRyaWNzOiBtZXRyaWNzIHx8IFtdLFxuICAgICAgICBldmVudHM6IGV2ZW50cyB8fCBbXSxcbiAgICAgICAgcGVyZm9ybWFuY2U6IHBlcmZvcm1hbmNlIHx8IFtdLFxuICAgICAgICBlbmdhZ2VtZW50OiBlbmdhZ2VtZW50IHx8IFtdXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCBhbmFseXRpY3MgZGF0YTonLCBlcnJvcilcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBhbmFseXRpY3NTZXJ2aWNlID0gbmV3IEFuYWx5dGljc1NlcnZpY2UoKSJdLCJuYW1lcyI6WyJzdXBhYmFzZSIsIkFuYWx5dGljc1NlcnZpY2UiLCJnZXRPckNyZWF0ZVNlc3Npb25JZCIsIk1hdGgiLCJEYXRlIiwibm93IiwicmFuZG9tIiwidG9TdHJpbmciLCJzdWJzdHIiLCJzZXNzaW9uSWQiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwic2V0SXRlbSIsInRyYWNrRXZlbnQiLCJldmVudFR5cGUiLCJldmVudERhdGEiLCJ1c2VySWQiLCJldmVudCIsInVzZXJfaWQiLCJldmVudF90eXBlIiwiZXZlbnRfZGF0YSIsInNlc3Npb25faWQiLCJpcF9hZGRyZXNzIiwidXNlcl9hZ2VudCIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImVycm9yIiwiZnJvbSIsImluc2VydCIsImNvbnNvbGUiLCJ3YXJuIiwidHJhY2tNb2RlbFBlcmZvcm1hbmNlIiwiY29udmVyc2F0aW9uSWQiLCJtb2RlbCIsIm1ldHJpY3MiLCJwZXJmb3JtYW5jZSIsImNvbnZlcnNhdGlvbl9pZCIsInByb21wdF90b2tlbnMiLCJwcm9tcHRUb2tlbnMiLCJjb21wbGV0aW9uX3Rva2VucyIsImNvbXBsZXRpb25Ub2tlbnMiLCJ0b3RhbF90b2tlbnMiLCJ0b3RhbFRva2VucyIsInJlc3BvbnNlX3RpbWVfbXMiLCJyZXNwb25zZVRpbWVNcyIsImNvc3RfY2VudHMiLCJjb3N0Q2VudHMiLCJzdWNjZXNzIiwiZXJyb3JfbWVzc2FnZSIsImVycm9yTWVzc2FnZSIsInVwZGF0ZVVzZXJFbmdhZ2VtZW50IiwidG9kYXkiLCJ0b0lTT1N0cmluZyIsInNwbGl0IiwidXBkYXRlRXJyb3IiLCJ1cGRhdGUiLCJsYXN0X2FjdGl2aXR5IiwidXBkYXRlZF9hdCIsImVxIiwiZW5nYWdlbWVudCIsImRhdGUiLCJtZXNzYWdlc19zZW50IiwiY29udmVyc2F0aW9uc19jcmVhdGVkIiwic2Vzc2lvbl9kdXJhdGlvbl9taW51dGVzIiwibW9kZWxzX3VzZWQiLCJmZWF0dXJlc191c2VkIiwiaW5zZXJ0RXJyb3IiLCJpbmNyZW1lbnRNZXNzYWdlQ291bnQiLCJkYXRhIiwiY3VycmVudERhdGEiLCJmZXRjaEVycm9yIiwic2VsZWN0Iiwic2luZ2xlIiwiY3VycmVudENvdW50IiwidXBzZXJ0RXJyb3IiLCJ1cHNlcnQiLCJvbkNvbmZsaWN0IiwiaW5jcmVtZW50Q29udmVyc2F0aW9uQ291bnQiLCJ0cmFja01vZGVsVXNhZ2UiLCJjb2RlIiwiY3VycmVudE1vZGVscyIsInVwZGF0ZWRNb2RlbHMiLCJBcnJheSIsIlNldCIsInRyYWNrRmVhdHVyZVVzYWdlIiwiZmVhdHVyZSIsImN1cnJlbnRGZWF0dXJlcyIsInVwZGF0ZWRGZWF0dXJlcyIsImdldEFuYWx5dGljc0RhdGEiLCJkYXRlUmFuZ2UiLCJtZXRyaWNzRXJyb3IiLCJndGUiLCJzdGFydCIsImx0ZSIsImVuZCIsIm9yZGVyIiwiYXNjZW5kaW5nIiwiZXZlbnRzIiwiZXZlbnRzRXJyb3IiLCJsaW1pdCIsInBlcmZvcm1hbmNlRXJyb3IiLCJlbmdhZ2VtZW50RXJyb3IiLCJhbmFseXRpY3NTZXJ2aWNlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/analyticsService.ts\n"));

/***/ })

}]);